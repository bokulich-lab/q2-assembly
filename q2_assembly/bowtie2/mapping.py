# ----------------------------------------------------------------------------
# Copyright (c) 2021, QIIME 2 development team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file LICENSE, distributed with this software.
# ----------------------------------------------------------------------------

import os
import shutil
import subprocess
import tempfile
from copy import deepcopy
from typing import Union

import pandas as pd
from q2_types.bowtie2 import Bowtie2IndexDirFmt
from q2_types.per_sample_sequences import (
    SingleLanePerSamplePairedEndFastqDirFmt,
    SingleLanePerSampleSingleEndFastqDirFmt
)
from q2_types_genomics.per_sample_data import (
    BAMDirFmt
)

from .utils import _process_bowtie2_arg
from .._utils import (_process_common_input_params, run_commands_with_pipe)


def _map_sample_reads(
        common_args, paired, sample_name, sample_inputs, result_fp):
    base_cmd = ['bowtie2']
    base_cmd.extend(common_args)

    with tempfile.TemporaryDirectory() as tmp:
        bam_result = os.path.join(tmp, 'alignment.bam')
        cmd = deepcopy(base_cmd)
        cmd.extend([
            '-x', sample_inputs['index'],
        ])

        if paired:
            cmd.extend(['-1', sample_inputs['fwd'],
                        '-2', sample_inputs['rev']])
        else:
            cmd.extend(['-U', sample_inputs['fwd']])

        try:
            run_commands_with_pipe(
                cmd1=cmd,
                cmd2=['samtools', 'view', '-bS', '-o', bam_result],
                verbose=True)
        except subprocess.CalledProcessError as e:
            raise Exception('An error was encountered while running Bowtie2, '
                            f'(return code {e.returncode}), please inspect '
                            'stdout and stderr to learn more.')

        shutil.move(os.path.join(tmp, 'alignment.bam'),
                    os.path.join(
                        str(result_fp), f'{sample_name}_alignment.bam'))

        # TODO: introduce support for the stats generated by bowtie
        #  (--met flag) and create a visualisation


def _gather_sample_data(indexed_contigs, reads_manifest, paired):
    full_set = {}
    for samp in list(reads_manifest.index):
        full_set[samp] = {
            'fwd': reads_manifest.loc[samp, 'forward'],
            'rev': reads_manifest.loc[samp, 'reverse'] if paired else None
        }
    for samp in full_set.keys():
        indpath = os.path.join(str(indexed_contigs), samp)
        if os.path.exists(indpath):
            full_set[samp]['index'] = os.path.join(indpath, 'index')
        else:
            raise Exception(f'Index files missing for sample {samp}. '
                            f'Please check your input.')
    return full_set


def map_reads_to_contigs(
        indexed_contigs: Bowtie2IndexDirFmt,
        reads: Union[SingleLanePerSamplePairedEndFastqDirFmt,
                     SingleLanePerSampleSingleEndFastqDirFmt],
        skip: int = None, qupto: int = None, trim5: int = None,
        trim3: int = None, trim_to: str = None, phred33: bool = False,
        phred64: bool = False, very_fast: bool = False, fast: bool = False,
        sensitive: bool = False, very_sensitive: bool = False,
        very_fast_local: bool = False, fast_local: bool = False,
        sensitive_local: bool = False, very_sensitive_local: bool = False,
        n: int = None, len: int = None, i: str = None, n_ceil: str = None,
        dpad: int = None, gbar: int = None, ignore_quals: bool = False,
        nofw: bool = False, norc: bool = False, no_1mm_upfront: bool = False,
        end_to_end: bool = False, local: bool = False, ma: int = None,
        mp: str = None, np: int = None, rdg: str = None, rfg: str = None,
        k: int = None, a: bool = False, d: int = None, r: int = None,
        minins: int = None, maxins: int = None,
        valid_mate_orientations: str = None, no_mixed: bool = False,
        no_discordant: bool = False, dovetail: bool = False,
        no_contain: bool = False, no_overlap: bool = False,
        offrate: int = None, threads: int = None, reorder: bool = False,
        mm: bool = False, seed: int = None, non_deterministic: bool = False
) -> BAMDirFmt:
    kwargs = {k: v for k, v in locals().items()
              if k not in ['indexed_contigs', 'reads']}
    common_args = _process_common_input_params(
        processing_func=_process_bowtie2_arg, params=kwargs
    )

    paired = isinstance(reads, SingleLanePerSamplePairedEndFastqDirFmt)
    manifest = reads.manifest.view(pd.DataFrame)

    full_sample_set = _gather_sample_data(indexed_contigs, manifest, paired)

    result = BAMDirFmt()
    for samp, props in full_sample_set.items():
        _map_sample_reads(common_args, paired, samp, props, str(result))

    return result
